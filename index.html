<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
    }
    #resultPage {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #f5f5f7;
      display: none;
      padding: 20px;
      text-align: center;
    }
    .card {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      margin: 20px auto;
      max-width: 600px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    .back-button {
      display: inline-block;
      padding: 10px 20px;
      background-color: #0066cc;
      color: white;
      border-radius: 20px;
      text-decoration: none;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="resultPage">
    <h1 id="resultTitle">Result</h1>
    <div class="card">
      <div id="resultContent">Content will appear here</div>
    </div>
    <button class="back-button" id="backButton">Return to Canvas</button>
  </div>

  <script>
    // Get canvas and context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Config
    const BUBBLE_SIZE = 200; // Large bubbles
    
    // Tools data
    const tools = [
      { id: 'market', name: 'Market Analysis', icon: 'ðŸ“Š', color: '#4CAF50' },
      { id: 'competitor', name: 'Competitor Intel', icon: 'ðŸ”', color: '#2196F3' },
      { id: 'strategy', name: 'Business Strategy', icon: 'ðŸŽ¯', color: '#9C27B0' },
      { id: 'forecast', name: 'Sales Forecast', icon: 'ðŸ“ˆ', color: '#FF5722' },
      { id: 'customer', name: 'Customer Insights', icon: 'ðŸ§ ', color: '#E91E63' }
    ];
    
    // Robot state
    let robot = {
      x: canvas.width - 120,
      y: canvas.height - 120,
      size: 80,
      animation: 0,
      blinking: false,
      processing: false,
      targetBubble: null
    };
    
    // Animation variables
    let portalActive = false;
    let portalSize = 0;
    
    // Initialize bubbles
    let bubbles = [];
    let isDragging = false;
    let draggedBubble = null;
    let lastClickTime = 0;
    
    // Create bubbles in a circle
    function createBubbles() {
      bubbles = [];
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) * 0.3;
      
      tools.forEach((tool, index) => {
        const angle = (index / tools.length) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        bubbles.push({
          id: tool.id,
          name: tool.name,
          icon: tool.icon,
          color: tool.color,
          x: x,
          y: y,
          size: BUBBLE_SIZE,
          hover: false,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          squishX: 1,
          squishY: 1
        });
      });
    }
    
    // Function to lighten color
    function lightenColor(color, percent) {
      const num = parseInt(color.slice(1), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, ((num >> 16) & 0xFF) + amt);
      const G = Math.min(255, ((num >> 8) & 0xFF) + amt);
      const B = Math.min(255, (num & 0xFF) + amt);
      return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
    }
    
    // Draw a rounded rectangle
    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
    
    // Update function
    function update() {
      // Update animation variables
      robot.animation += 0.05;
      robot.blinking = Math.random() < 0.005;
      
      // Update bubbles
      bubbles.forEach(bubble => {
        if (bubble === draggedBubble || bubble === robot.targetBubble) {
          return;
        }
        
        // Move bubble
        bubble.x += bubble.vx;
        bubble.y += bubble.vy;
        
        // Boundary collision
        const margin = 50;
        const halfSize = bubble.size / 2;
        
        if (bubble.x - halfSize < margin) {
          bubble.x = margin + halfSize;
          bubble.vx *= -1;
          bubble.squishX = 0.8;
          bubble.squishY = 1.2;
        } else if (bubble.x + halfSize > canvas.width - margin) {
          bubble.x = canvas.width - margin - halfSize;
          bubble.vx *= -1;
          bubble.squishX = 0.8;
          bubble.squishY = 1.2;
        }
        
        if (bubble.y - halfSize < margin) {
          bubble.y = margin + halfSize;
          bubble.vy *= -1;
          bubble.squishX = 1.2;
          bubble.squishY = 0.8;
        } else if (bubble.y + halfSize > canvas.height - margin) {
          bubble.y = canvas.height - margin - halfSize;
          bubble.vy *= -1;
          bubble.squishX = 1.2;
          bubble.squishY = 0.8;
        }
        
        // Return to normal shape
        bubble.squishX += (1 - bubble.squishX) * 0.1;
        bubble.squishY += (1 - bubble.squishY) * 0.1;
        
        // Add randomness and damping
        bubble.vx += (Math.random() - 0.5) * 0.01;
        bubble.vy += (Math.random() - 0.5) * 0.01;
        bubble.vx *= 0.99;
        bubble.vy *= 0.99;
      });
      
      // Handle robot processing
      if (robot.processing && robot.targetBubble) {
        const bubble = robot.targetBubble;
        const dx = bubble.x - robot.x;
        const dy = bubble.y - robot.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 10) {
          robot.x += dx * 0.05;
          robot.y += dy * 0.05;
        } else {
          // Start portal animation
          portalActive = true;
          
          if (portalSize < 300) {
            portalSize += 5;
          } else {
            // Show results page
            setTimeout(() => {
              showResults(bubble);
              
              // Remove the bubble
              bubbles = bubbles.filter(b => b !== bubble);
              
              // Reset robot and portal
              portalActive = false;
              portalSize = 0;
              robot.processing = false;
              robot.targetBubble = null;
              robot.x = canvas.width - 120;
              robot.y = canvas.height - 120;
            }, 500);
          }
        }
      }
    }
    
    // Draw function
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw portal if active
      if (portalActive) {
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        
        // Portal gradient
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, portalSize);
        gradient.addColorStop(0, 'rgba(120, 0, 255, 0.8)');
        gradient.addColorStop(0.7, 'rgba(80, 0, 180, 0.5)');
        gradient.addColorStop(1, 'rgba(50, 0, 120, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, portalSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Portal swirl
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let i = 0; i < Math.PI * 6; i += 0.1) {
          const radius = i * 6;
          const x = Math.cos(i + robot.animation * 0.1) * radius/5;
          const y = Math.sin(i + robot.animation * 0.1) * radius/5;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          
          if (radius > portalSize * 0.8) break;
        }
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Draw bubbles
      bubbles.forEach(bubble => {
        ctx.save();
        ctx.translate(bubble.x, bubble.y);
        ctx.scale(bubble.squishX, bubble.squishY);
        
        // Shadow for 3D effect
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        drawRoundedRect(-bubble.size/2 + 10, -bubble.size/2 + 10, bubble.size, bubble.size, bubble.size/6);
        ctx.fill();
        
        // Main bubble body
        const gradient = ctx.createLinearGradient(0, -bubble.size/2, 0, bubble.size/2);
        gradient.addColorStop(0, lightenColor(bubble.color, 20));
        gradient.addColorStop(1, bubble.color);
        
        ctx.fillStyle = bubble.hover ? lightenColor(bubble.color, 30) : gradient;
        drawRoundedRect(-bubble.size/2, -bubble.size/2, bubble.size, bubble.size, bubble.size/6);
        ctx.fill();
        
        // Top highlight
        const highlightGradient = ctx.createLinearGradient(0, -bubble.size/2, 0, 0);
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = highlightGradient;
        ctx.beginPath();
        ctx.moveTo(-bubble.size/2 + bubble.size/6, -bubble.size/2);
        ctx.lineTo(bubble.size/2 - bubble.size/6, -bubble.size/2);
        ctx.quadraticCurveTo(bubble.size/2, -bubble.size/2, bubble.size/2, -bubble.size/2 + bubble.size/6);
        ctx.lineTo(bubble.size/2, 0);
        ctx.lineTo(-bubble.size/2, 0);
        ctx.lineTo(-bubble.size/2, -bubble.size/2 + bubble.size/6);
        ctx.quadraticCurveTo(-bubble.size/2, -bubble.size/2, -bubble.size/2 + bubble.size/6, -bubble.size/2);
        ctx.closePath();
        ctx.fill();
        
        // Highlight border when hovered
        if (bubble.hover) {
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = 4;
          drawRoundedRect(-bubble.size/2 - 2, -bubble.size/2 - 2, bubble.size + 4, bubble.size + 4, bubble.size/6 + 2);
          ctx.stroke();
        }
        
        // Draw content
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Icon
        ctx.font = `${bubble.size/4}px Arial`;
        ctx.fillText(bubble.icon, 0, -bubble.size/6);
        
        // Text
        ctx.font = `bold ${bubble.size/10}px Arial`;
        ctx.fillText(bubble.name, 0, bubble.size/6);
        
        ctx.restore();
      });
      
      // Draw robot
      drawRobot();
      
      // Draw instructions
      if (!robot.processing && !portalActive) {
        // Main instruction
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        drawRoundedRect(canvas.width/2 - 200, canvas.height - 80, 400, 40, 20);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Drag bubbles or click one to process with the robot', canvas.width/2, canvas.height - 60);
        
        // Double-click instruction
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        drawRoundedRect(canvas.width/2 - 150, canvas.height - 30, 300, 30, 15);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.fillText('Double-click on bubble to learn more', canvas.width/2, canvas.height - 15);
      }
    }
    
    // Draw the robot
    function drawRobot() {
      ctx.save();
      ctx.translate(robot.x, robot.y);
      
      // Head shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.arc(3, 3, robot.size/2, 0, Math.PI * 2);
      ctx.fill();
      
      // Head gradient
      const headGradient = ctx.createLinearGradient(-robot.size/2, -robot.size/2, robot.size/2, robot.size/2);
      headGradient.addColorStop(0, '#FFD700');
      headGradient.addColorStop(1, '#DAA520');
      
      ctx.fillStyle = headGradient;
      ctx.beginPath();
      ctx.arc(0, 0, robot.size/2, 0, Math.PI * 2);
      ctx.fill();
      
      // Face plate
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.ellipse(0, 0, robot.size*0.3, robot.size*0.2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes
      const eyeSize = robot.size/8;
      const eyeSpacing = robot.size/5;
      
      ctx.fillStyle = portalActive ? '#FF3333' : '#FFA500';
      
      // Left eye
      ctx.beginPath();
      if (robot.blinking) {
        ctx.fillRect(-eyeSpacing - eyeSize/2, -eyeSize/4, eyeSize, eyeSize/4);
      } else {
        ctx.arc(-eyeSpacing, 0, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlight
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(-eyeSpacing - eyeSize/2, -eyeSize/2, eyeSize/3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Right eye
      ctx.fillStyle = portalActive ? '#FF3333' : '#FFA500';
      ctx.beginPath();
      if (robot.blinking) {
        ctx.fillRect(eyeSpacing - eyeSize/2, -eyeSize/4, eyeSize, eyeSize/4);
      } else {
        ctx.arc(eyeSpacing, 0, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlight
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(eyeSpacing - eyeSize/2, -eyeSize/2, eyeSize/3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Antennas
      const antennaHeight = robot.size/3;
      const wobble = Math.sin(robot.animation) * 5;
      
      // Left antenna
      ctx.save();
      ctx.translate(-robot.size/4, -robot.size/2);
      ctx.rotate((wobble - 5) * Math.PI/180);
      
      ctx.fillStyle = '#DAA520';
      ctx.fillRect(-1, -antennaHeight, 2, antennaHeight);
      
      ctx.fillStyle = '#FFA500';
      ctx.beginPath();
      ctx.arc(0, -antennaHeight, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      // Right antenna
      ctx.save();
      ctx.translate(robot.size/4, -robot.size/2);
      ctx.rotate((-wobble - 5) * Math.PI/180);
      
      ctx.fillStyle = '#DAA520';
      ctx.fillRect(-1, -antennaHeight, 2, antennaHeight);
      
      ctx.fillStyle = '#FFA500';
      ctx.beginPath();
      ctx.arc(0, -antennaHeight, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      ctx.restore();
    }
    
    // Show results page
    function showResults(bubble) {
      document.getElementById('resultTitle').textContent = bubble.name;
      
      let content = '';
      switch(bubble.id) {
        case 'market':
          content = `
            <h2>Market Analysis Results</h2>
            <p><strong>Market Size:</strong> $2.3 Billion</p>
            <p><strong>Growth Rate:</strong> 8.7% Year-over-Year</p>
            <p><strong>Key Recommendation:</strong> Focus on expanding in the Western European market.</p>
          `;
          break;
        case 'competitor':
          content = `
            <h2>Competitor Intelligence</h2>
            <p><strong>Major Competitors:</strong> 7</p>
            <p><strong>Leading Competitor:</strong> TechGiant Inc.</p>
            <p><strong>Key Recommendation:</strong> Differentiate through enhanced product integrations.</p>
          `;
          break;
        case 'strategy':
          content = `
            <h2>Strategic Recommendations</h2>
            <p><strong>CAGR:</strong> 14.2%</p>
            <p><strong>ROI:</strong> 127%</p>
            <p><strong>Key Recommendation:</strong> Implement a product-led growth strategy.</p>
          `;
          break;
        case 'forecast':
          content = `
            <h2>Sales Forecast</h2>
            <p><strong>Annual Revenue:</strong> $12.7M</p>
            <p><strong>Projected Growth:</strong> 23%</p>
            <p><strong>Key Recommendation:</strong> Create specialized sales teams for enterprise accounts.</p>
          `;
          break;
        case 'customer':
          content = `
            <h2>Customer Insights</h2>
            <p><strong>NPS Score:</strong> 68</p>
            <p><strong>Customer Retention:</strong> 87%</p>
            <p><strong>Key Recommendation:</strong> Create personalized onboarding for different user segments.</p>
          `;
          break;
      }
      
      document.getElementById('resultContent').innerHTML = content;
      document.getElementById('resultPage').style.display = 'block';
    }
    
    // Handle mouse movement
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Update hover states
      let hovering = false;
      bubbles.forEach(bubble => {
        const dx = mouseX - bubble.x;
        const dy = mouseY - bubble.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        bubble.hover = distance < bubble.size / 2;
        if (bubble.hover) hovering = true;
      });
      
      canvas.style.cursor = hovering ? 'pointer' : 'default';
      
      // Update dragged bubble position
      if (isDragging && draggedBubble) {
        draggedBubble.x = mouseX;
        draggedBubble.y = mouseY;
      }
    });
    
    // Handle mouse down
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Check for double click
      const now = new Date().getTime();
      const timeSinceLastClick = now - lastClickTime;
      lastClickTime = now;
      
      // Check each bubble
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const bubble = bubbles[i];
        const dx = mouseX - bubble.x;
        const dy = mouseY - bubble.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < bubble.size / 2) {
          // Double click
          if (timeSinceLastClick < 300) {
            showResults(bubble);
            return;
          }
          
          // Start dragging
          isDragging = true;
          draggedBubble = bubble;
          
          // Move to top
          bubbles.splice(i, 1);
          bubbles.push(bubble);
          return;
        }
      }
    });
    
    // Handle mouse up
    canvas.addEventListener('mouseup', (e) => {
      if (isDragging && draggedBubble) {
        // Check if it was a click
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const dx = mouseX - draggedBubble.x;
        const dy = mouseY - draggedBubble.y;
        const dragDistance = Math.sqrt(dx * dx + dy * dy);
        
        if (dragDistance < 5 && !robot.processing) {
          robot.processing = true;
          robot.targetBubble = draggedBubble;
        }
        
        isDragging = false;
        draggedBubble = null;
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Update robot position
      robot.x = canvas.width - 120;
      robot.y = canvas.height - 120;
      
      // Recreate bubbles
      createBubbles();
    });
    
    // Back button
    document.getElementById('backButton').addEventListener('click', () => {
      document.getElementById('resultPage').style.display = 'none';
      
      // Recreate bubbles if all are gone
      if (bubbles.length === 0) {
        createBubbles();
      }
    });
    
    // Animation loop
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // Initialize
    createBubbles();
    animate();
  </script>
</body>
</html>